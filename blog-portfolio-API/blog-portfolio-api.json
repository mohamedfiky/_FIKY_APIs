[
    {
        "id": 1,
        "author":"Mohamed El-Fiky",
        "date":"30-May-1990",
        "title": "WEB WIREFRAMES",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/1.jpg",
        "content":"The current trend seems to be to focus on providing a Container → an easy way to nest components. Ideally using Web Components to reduce the JavaScript related logic close to zero. Developers often end up with “supercharging” HTML and getting a rough time with creating complex apps. This already starts with submitting forms and manually writing massive (not maintainable) form services. In my opinion, a framework should provide a declarative, robust and easy to use abstraction layer instead. Programmers can easily focus on the business logic and get useful tools like state management (view models), which we can nest as needed, view controllers and focus on app related bindings and events to create meaningful architectures which are extensible and scalable. Our weapon of choice is JavaScript. That this is creating HTML related output is a nice coincidence, but nothing we want to deal with on a daily basis. If we then get access to the latest Web APIs like OffscreenCanvas, we can create next generation user interfaces with an incredible speed. A development mode which runs without any builds or transpilations while supporting lazy loading and the latest ECMAScript features once the browser support is in place further boosts this."
    },
    {
        "id": 2,
        "author":"John Doe Abdel-Aal",
        "date":"04-Jan-2023",
        "title": "WEB ANALYSIS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/2.jpg",
        "content":"It's tough to make predictions, especially about the future. That doesn't mean people don't try. Recent advances in Artificial Intelligence have a lot of people predicting what jobs are an are not likely to be replaced by computers. Technology is challenging the ideas about what jobs can and cannot be replaced by technology. Doug Peterson, who shares a lot of interesting articles, recently share this one predicting that leaders will not be replace. It's an optimistic article. 5 Reasons Leaders Shouldn't Worry That Generative A.I. Will Take Their Jobs | Inc.com A lot of jobs we once thought were completely safe are being seen in a new way lately. AIs are creating what looks to many like art for example. This is forcing us to take a hard look at how we define art. Some recent visits to museums had me already asking “what is art?” Today we joke about AI attempts to write short stories, poetry, and other narratives. A lot of our stories in movies an even books are formulaic. How long before AIs can write Hallmark Christmas movies I wonder? What used to be a joke may be a prediction of the future. A lot of people are speculating on  the future end of the programmer profession. People have been predicting that would decades but we are closer to that than ever before. Software developers today think they are safe though because they (we) know that end users are terrible about describing what they want a program to do. Will the future bring courses and training on how to talk to AIs? Possibly. I can sure see the need for it. People who are not teachers are suggesting that AIs will take over for human teachers. As someone who spent 15 years teaching I am not so sure about that. I think the human touch will remain important for the future. Teaching is a lot about reading people and establishing relationships. Wil AI be able to do that? I am not sure anyone knows. One area I think people have an advantage over AI is that we are bad with risk analysis. What may seem like a flaw leads people with some luck, some imagination, and some hard work to beat the odds. We see potential needs when a pure look at the data would not see anything. And we are often willing to defy the odds for things we believe in. I am not sure AI will get there. Thinking about the possibilities of AI and what it means for the future of work is a critical topic. It’s something we need everyone, but especially students, to be thinking about.",
        "isPortfolio" : true,
        "portfolioTitle":"WEB ANALYSIS SERVICES"
    },
    {
        "id": 3,
        "author":"Mohamed Tharwat",
        "date":"14-Feb-2022",
        "title": "BUSINESS PLANNING",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/3.jpg",
        "content":"An increasing annoyance in my day-to-day job as a coach and trainer is what I call FPF, or “Functional Programming Fanaticism”. Typically, it emanates from people who’ve recently discovered FP in the last few years and have yet to realize that — like all programming innovations since the 1940s — it doesn’t actually solve all the problems for us. Putting aside the widely-held perception that functional programs can be considerably less easy to understand, even for experienced FP-ers, (and this is no small consideration when you realize that trying to understand program code is where programmers spend at least half our time), there is the question of side effects. More specifically, people keep telling me that functional programs don’t have any. This is patently not true: a program with no side effects is a program that does nothing of any use to us. Somewhere, somehow, data’s got to change. Try writing a word processor that doesn’t have side effects.",
        "isPortfolio" : true,
        "portfolioTitle":"BUSINESS PLANNING SERVICES"
    },
    {
        "id": 4,
        "author":"Adel El-Banna",
        "date":"31-Aug-2017",
        "title": "SUCCESS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/4.jpg",
        "content":"Why do you use a programming language? The simple answer is to code. However, this answer does not provide insight into how programming languages work, nor which one you should use for a given task. Understanding the timeline of a technology is critical to using it effectively. Therefore, learning about the history of programming languages is important. A programming language functions as an interface between humans and machines. In other words, humans use programming languages to tell man-made machines how to run. The alternative to using a programming language is not using software at all. Yet this is not productive for mathematical operations. Such that the computer was born with virtual programs coming not long after."
    },
    {
        "id": 5,
        "author":"Mohamed Dobal",
        "date":"19-May-2015",
        "title": "ANALYSIS TOOLS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/5.jpg",
        "content":"The current trend seems to be to focus on providing a Container → an easy way to nest components. Ideally using Web Components to reduce the JavaScript related logic close to zero. Developers often end up with “supercharging” HTML and getting a rough time with creating complex apps. This already starts with submitting forms and manually writing massive (not maintainable) form services. In my opinion, a framework should provide a declarative, robust and easy to use abstraction layer instead. Programmers can easily focus on the business logic and get useful tools like state management (view models), which we can nest as needed, view controllers and focus on app related bindings and events to create meaningful architectures which are extensible and scalable. Our weapon of choice is JavaScript. That this is creating HTML related output is a nice coincidence, but nothing we want to deal with on a daily basis. If we then get access to the latest Web APIs like OffscreenCanvas, we can create next generation user interfaces with an incredible speed. A development mode which runs without any builds or transpilations while supporting lazy loading and the latest ECMAScript features once the browser support is in place further boosts this.",
        "isPortfolio" : true,
        "portfolioTitle":"ANALYZING DATA"
    },
    {
        "id": 6,
        "author":"Abdo El-Fiky",
        "date":"23-Sep-1991",
        "title": "AGILE APPROACH",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/6.jpg",
        "content":"It's tough to make predictions, especially about the future. That doesn't mean people don't try. Recent advances in Artificial Intelligence have a lot of people predicting what jobs are an are not likely to be replaced by computers. Technology is challenging the ideas about what jobs can and cannot be replaced by technology. Doug Peterson, who shares a lot of interesting articles, recently share this one predicting that leaders will not be replace. It's an optimistic article. 5 Reasons Leaders Shouldn't Worry That Generative A.I. Will Take Their Jobs | Inc.com A lot of jobs we once thought were completely safe are being seen in a new way lately. AIs are creating what looks to many like art for example. This is forcing us to take a hard look at how we define art. Some recent visits to museums had me already asking “what is art?” Today we joke about AI attempts to write short stories, poetry, and other narratives. A lot of our stories in movies an even books are formulaic. How long before AIs can write Hallmark Christmas movies I wonder? What used to be a joke may be a prediction of the future. A lot of people are speculating on  the future end of the programmer profession. People have been predicting that would decades but we are closer to that than ever before. Software developers today think they are safe though because they (we) know that end users are terrible about describing what they want a program to do. Will the future bring courses and training on how to talk to AIs? Possibly. I can sure see the need for it. People who are not teachers are suggesting that AIs will take over for human teachers. As someone who spent 15 years teaching I am not so sure about that. I think the human touch will remain important for the future. Teaching is a lot about reading people and establishing relationships. Wil AI be able to do that? I am not sure anyone knows. One area I think people have an advantage over AI is that we are bad with risk analysis. What may seem like a flaw leads people with some luck, some imagination, and some hard work to beat the odds. We see potential needs when a pure look at the data would not see anything. And we are often willing to defy the odds for things we believe in. I am not sure AI will get there. Thinking about the possibilities of AI and what it means for the future of work is a critical topic. It’s something we need everyone, but especially students, to be thinking about."
    },
    {
        "id": 7,
        "author":"Abdo El-Sayed",
        "date":"24-Aug-2020",
        "title": "CLEAR GOALS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/7.jpg",
        "content":"An increasing annoyance in my day-to-day job as a coach and trainer is what I call FPF, or “Functional Programming Fanaticism”. Typically, it emanates from people who’ve recently discovered FP in the last few years and have yet to realize that — like all programming innovations since the 1940s — it doesn’t actually solve all the problems for us. Putting aside the widely-held perception that functional programs can be considerably less easy to understand, even for experienced FP-ers, (and this is no small consideration when you realize that trying to understand program code is where programmers spend at least half our time), there is the question of side effects. More specifically, people keep telling me that functional programs don’t have any. This is patently not true: a program with no side effects is a program that does nothing of any use to us. Somewhere, somehow, data’s got to change. Try writing a word processor that doesn’t have side effects."
    },
    {
        "id": 8,
        "author":"Amir Tariq",
        "date":"31-Oct-1999",
        "title": "WEB STATISTICS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/8.jpg",
        "content":"Why do you use a programming language? The simple answer is to code. However, this answer does not provide insight into how programming languages work, nor which one you should use for a given task. Understanding the timeline of a technology is critical to using it effectively. Therefore, learning about the history of programming languages is important. A programming language functions as an interface between humans and machines. In other words, humans use programming languages to tell man-made machines how to run. The alternative to using a programming language is not using software at all. Yet this is not productive for mathematical operations. Such that the computer was born with virtual programs coming not long after.",
        "isPortfolio" : true,
        "portfolioTitle":"WEBSITES STATISTICS"
    },
    {
        "id": 9,
        "author":"Mohamed El-Mahalawy",
        "date":"30-may-1990",
        "title": "SUCCESS TRIANGLE",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/9.jpg",
        "content":"Functional Programing helps us write more reliable code — in particular, more reliable concurrent code — by limiting and localizing side effects. But only if you do it right. It’s entirely possible to write functional programs that are riddled with concurrency errors, and, indeed, that’s what many teams are doing as we speak. How can this be so, though, if functions are said to be “clean” — side-effect free? Well, that bank account balance that gets passed from one function to next may indeed be a copy (of a copy of a copy) of the original balance, but from the external user’s perspective, whatever the current balance is, that is the balance (and it has changed.) The moment we persist that change (e.g., by writing it to the database, or through transactional memory, or however we’re handling shared data), the deed is done. Ipso facto: side effect. Languages like Haskell, Clojure and that other one that sounds like “Camel” don’t do our concurrent thinking for us. If joint account holder A checks their balance before trying to use the debit card, but joint account holder B uses their debit card before A does, then — you may be surprised to learn — these languages have no built-in feature for reconciling joint account transaction paradoxes like this. You have to THINK ABOUT HOW YOUR SOFTWARE SHOULD HANDLE CONCURRENT SCENARIOS from the user’s perspective.",
        "isPortfolio" : true,
        "portfolioTitle":"RESOURCES MANAGEMENT"
    },
    {
        "id": 10,
        "author":"Shikabala",
        "date":"06-Nov-2012",
        "title": "ONLINE MARKETING",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/10.png",
        "content":"In non-FP work, we seek to make concurrent systems more reliable and more, well, concurrent, by strictly limiting and localizing concurrent access to shared data. FP just embeds this concept within the languages themselves, making that easier and more reliable to do. Just as workflow frameworks don’t decide what should happen in your workflows, functional programs don’t decide how your application should handle side-effects. The best they can do is give you the tools to realize the decisions you make. What I’m seeing, though, (and this was case when we were all prostrating before the Great Workflow Ju Ju In The Sky a decade or so ago), is that teams mistakenly lean on the technology, believing through some kind of magic that it will handle these scenarios for them. But, like all computer programs, they will only do exactly what we tell them to.",
        "isPortfolio" : true,
        "portfolioTitle":"ONLINE MARKETING CAMPAIGNS"
    },
    {
        "id": 11,
        "author":"Said Hatata",
        "date":"16-Dec-2011",
        "title": "WIREFRAMING",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/11.jpg",
        "content":"The “History of Programming Languages” and “Timeline of Programming Languages” documents showcase various programming languages alongside their objectives, predecessors, and successors. Knowledge of these tools will assist you in creating more performant programs in a maintainable manner. With that being said, modern programming languages are typically broken down into specific categories to highlight their use cases. Understanding the meaning of compiled and interpreted (in computing) highlights the difference between compiled and interpreted programming languages. As a reminder, a compiler compiles code from one form (i.e human readable code) to another (i.e machine code). A compiled language implies that the language will NOT use an interpreter at runtime, which is typically beneficial for performance. In contrast, an interpreted language implies that the language will be interpreted at runtime, which is typically beneficial for code iteration (programmer productivity).",
        "isPortfolio" : true,
        "portfolioTitle":"WEB WIREFRAMING"
    },
    {
        "id": 12,
        "author":"Taha Zainden",
        "date":"20-Apr-2003",
        "title": "CHECKED LIST",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/12.jpg",
        "content":"Programming languages may be referred to by the way they handle computer memory. Processing bits on a Computer Processing Unit (CPU) is fast, but what if you need to store information (i.e variables)? Computer memory solves this problem at the cost of speed (in a similar manner to a Hard Drive). The difference being that Random Access Memory (RAM) is built for retrieval while Hard Drives (and similar technologies) are built for resilient storage. As a reminder RAM is erased when a computer shuts down. Unexpected operations occur when a computer handles memory incorrectly. Such that certain languages do NOT require memory management in lieu of their own automated form of memory management (i.e Garbage Collectors). Managed memory programming languages function as an alternative to unmanaged memory programming languages which require you to manually manage memory of the computer."
    },
    {
        "id": 13,
        "author":"Mohamed Badran",
        "date":"25-Jun-2000",
        "title": "KEYWORDS",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/13.jpg",
        "content":"Machine code represents the language of computers which use bits (1s and 0s). Of course, writing 1s and 0s to create programs is tedious and complex for humans. As a result, computer programs called compilers were created in order to convert human-readable code into machine code. Once compiled, a program is interpreted using an interpreter. As an example, the Computer Processing Unit (CPU) is the final interpreter of machine code. From this point onwards, a pattern emerged: Programming languages were created in order to make it easier for humans to read and write code. Rather than compile to machine code, certain languages (i.e C) would compile to other languages (i.e Assembly) which compiles to machine code. This led to the separation of languages into levels such as high-level programming languages and low-level programming languages."
    },
    {
        "id": 14,
        "author":"Ashraf Badran",
        "date":"04-Jul-2023",
        "title": "CYBER SECURITY",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/14.jpg",
        "content":"Why do you use a programming language? The simple answer is to code. However, this answer does not provide insight into how programming languages work, nor which one you should use for a given task. Understanding the timeline of a technology is critical to using it effectively. Therefore, learning about the history of programming languages is important. A programming language functions as an interface between humans and machines. In other words, humans use programming languages to tell man-made machines how to run. The alternative to using a programming language is not using software at all. Yet this is not productive for mathematical operations. Such that the computer was born with virtual programs coming not long after.",
        "isPortfolio" : true,
        "portfolioTitle":"CYBER SECURITY"
    },
    {
        "id": 15,
        "author":"Amr Zahran",
        "date":"14-Mar-2021",
        "title": "ACCURATE DEADLINES",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/15.jpg",
        "content":"With all this growing responsibility, it can no longer be about just equipping developers with tools so they can do more. We need to give developers everything they need to focus on doing their best work. GitHub is the home of all developers. This is our vision. From creating the pull request to empowering developers with AI through GitHub Copilot, everything we do has been to put the developer first. And it’s just the beginning. With GitHub Next, our research and development team is investigating the future of software development. From Code Brushes to Hey, GitHub!, GitHub Next has been pivotal in ensuring GitHub is the home for all developers. As the home for 100 million developers and counting, we take our responsibility seriously to help bring more new developers into technology and help people work together to build the next great thing, accelerate human progress, and solve problems we don’t yet understand. Because when more developers work together and have everything they need to be at their best, incredible things happen for everyone. So, let’s build from here—together."
    },
    {
        "id": 16,
        "author":"Eslam El-Azazy",
        "date":"31-Dec-2019",
        "title": "MACHINE LEARNING",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/16.jpg",
        "content":"Machine code represents the language of computers which use bits (1s and 0s). Of course, writing 1s and 0s to create programs is tedious and complex for humans. As a result, computer programs called compilers were created in order to convert human-readable code into machine code. Once compiled, a program is interpreted using an interpreter. As an example, the Computer Processing Unit (CPU) is the final interpreter of machine code. From this point onwards, a pattern emerged: Programming languages were created in order to make it easier for humans to read and write code. Rather than compile to machine code, certain languages (i.e C) would compile to other languages (i.e Assembly) which compiles to machine code. This led to the separation of languages into levels such as high-level programming languages and low-level programming languages.",
        "isPortfolio" : true,
        "portfolioTitle":"MACHINE LEARNING SERVICES"
    },
    {
        "id": 17,
        "author":"Hossam Abdel-Naccer",
        "date":"11-Jan-2016",
        "title": "SOCIAL MEDIA",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/17.jpg",
        "content":"Programming languages may be referred to by the way they handle computer memory. Processing bits on a Computer Processing Unit (CPU) is fast, but what if you need to store information (i.e variables)? Computer memory solves this problem at the cost of speed (in a similar manner to a Hard Drive). The difference being that Random Access Memory (RAM) is built for retrieval while Hard Drives (and similar technologies) are built for resilient storage. As a reminder RAM is erased when a computer shuts down. Unexpected operations occur when a computer handles memory incorrectly. Such that certain languages do NOT require memory management in lieu of their own automated form of memory management (i.e Garbage Collectors). Managed memory programming languages function as an alternative to unmanaged memory programming languages which require you to manually manage memory of the computer.",
        "isPortfolio" : true,
        "portfolioTitle":"SOCIAL MEDIA CAMPAIGNS"
    },
    {
        "id": 18,
        "author":"Eltab3y Assasa",
        "date":"03-Nov-1997",
        "title": "QUANTITY VS QUALITY",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/18.png",
        "content":"The “History of Programming Languages” and “Timeline of Programming Languages” documents showcase various programming languages alongside their objectives, predecessors, and successors. Knowledge of these tools will assist you in creating more performant programs in a maintainable manner. With that being said, modern programming languages are typically broken down into specific categories to highlight their use cases. Understanding the meaning of compiled and interpreted (in computing) highlights the difference between compiled and interpreted programming languages. As a reminder, a compiler compiles code from one form (i.e human readable code) to another (i.e machine code). A compiled language implies that the language will NOT use an interpreter at runtime, which is typically beneficial for performance. In contrast, an interpreted language implies that the language will be interpreted at runtime, which is typically beneficial for code iteration (programmer productivity)."
    },
    {
        "id": 19,
        "author":"Karim Menisey",
        "date":"23-Jun-2018",
        "title": "SEARCH ENGINE OPTIMIZATION",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/19.jpg",
        "content":"In non-FP work, we seek to make concurrent systems more reliable and more, well, concurrent, by strictly limiting and localizing concurrent access to shared data. FP just embeds this concept within the languages themselves, making that easier and more reliable to do. Just as workflow frameworks don’t decide what should happen in your workflows, functional programs don’t decide how your application should handle side-effects. The best they can do is give you the tools to realize the decisions you make. What I’m seeing, though, (and this was case when we were all prostrating before the Great Workflow Ju Ju In The Sky a decade or so ago), is that teams mistakenly lean on the technology, believing through some kind of magic that it will handle these scenarios for them. But, like all computer programs, they will only do exactly what we tell them to.",
        "isPortfolio" : true,
        "portfolioTitle":"SEO SERVICES"
    },
    {
        "id": 20,
        "author":"Mohamed Hamada",
        "date":"30-may-1990",
        "title": "PROJECT MANAGEMENT",
        "imgUrl":"https://raw.githubusercontent.com/mohamedfiky/_FIKY_APIs/master/blog-portfolio-API/blog-portfolio-images/20.jpg",
        "content":"Functional Programing helps us write more reliable code — in particular, more reliable concurrent code — by limiting and localizing side effects. But only if you do it right. It’s entirely possible to write functional programs that are riddled with concurrency errors, and, indeed, that’s what many teams are doing as we speak. How can this be so, though, if functions are said to be “clean” — side-effect free? Well, that bank account balance that gets passed from one function to next may indeed be a copy (of a copy of a copy) of the original balance, but from the external user’s perspective, whatever the current balance is, that is the balance (and it has changed.) The moment we persist that change (e.g., by writing it to the database, or through transactional memory, or however we’re handling shared data), the deed is done. Ipso facto: side effect. Languages like Haskell, Clojure and that other one that sounds like “Camel” don’t do our concurrent thinking for us. If joint account holder A checks their balance before trying to use the debit card, but joint account holder B uses their debit card before A does, then — you may be surprised to learn — these languages have no built-in feature for reconciling joint account transaction paradoxes like this. You have to THINK ABOUT HOW YOUR SOFTWARE SHOULD HANDLE CONCURRENT SCENARIOS from the user’s perspective.",
        "isPortfolio" : true,
        "portfolioTitle":"PROJECT MANAGEMENT"
    }
    
    
]